{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 71, "column": 0}, "map": {"version":3,"sources":["file:///home/kaif9999/genvr/TexttoVideo/src/app/api/flux1/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport Replicate from \"replicate\";\nimport { writeFile } from \"node:fs/promises\";\nimport path from \"path\";\nimport fs from \"fs\";\n\n// Initialize Replicate API client\nconst replicate = new Replicate({\n  auth: process.env.REPLICATE_API_KEY || \"\", // Ensure the API key is set\n});\n\nexport async function POST(req: Request) {\n  try {\n    const { text } = await req.json(); // Get the text input from the request body\n\n    if (!text || typeof text !== \"string\") {\n      return NextResponse.json(\n        { error: \"Text input is required!\" },\n        { status: 400 }\n      );\n    }\n\n    const input = {\n      prompt: text, // Use the transcribed text as the prompt\n    };\n\n    // Call the Replicate API to generate images based on the text\n    const output = await replicate.run(\"black-forest-labs/flux-dev-lora\", { input }) as string[];\n\n    if (!Array.isArray(output) || output.length === 0) {\n      return NextResponse.json(\n        { error: \"No images generated by the API.\" },\n        { status: 500 }\n      );\n    }\n\n    // Create an output folder if it doesn't exist\n    const outputDir = path.join(process.cwd(), \"public\", \"generated\");\n    if (!fs.existsSync(outputDir)) {\n      fs.mkdirSync(outputDir, { recursive: true });\n    }\n\n    // Prepare an array to hold the file paths of the saved images\n    const imagePaths = [];\n\n    // Save each image to disk\n    for (const [index, item] of output.entries()) {\n      const filePath = path.join(outputDir, `output_${index}.webp`);\n      await writeFile(filePath, Buffer.from(item, \"base64\")); // Ensure the data is written correctly\n      imagePaths.push(`/generated/output_${index}.webp`); // Store the relative path for frontend access\n    }\n\n    // Return the generated image URLs\n    return NextResponse.json({\n      imageUrls: imagePaths, // Array of image URLs\n    });\n  } catch (error) {\n    console.error(\"Error while generating images:\", error);\n\n    // Provide a user-friendly error message and log the actual error for debugging\n    return NextResponse.json(\n      { error: \"An error occurred while processing your request.\" },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA,kCAAkC;AAClC,MAAM,YAAY,IAAI,oIAAA,CAAA,UAAS,CAAC;IAC9B,MAAM,QAAQ,GAAG,CAAC,iBAAiB,IAAI;AACzC;AAEO,eAAe,KAAK,GAAY;IACrC,IAAI;QACF,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,IAAI,IAAI,IAAI,2CAA2C;QAE9E,IAAI,CAAC,QAAQ,OAAO,SAAS,UAAU;YACrC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA0B,GACnC;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,QAAQ;YACZ,QAAQ;QACV;QAEA,8DAA8D;QAC9D,MAAM,SAAS,MAAM,UAAU,GAAG,CAAC,mCAAmC;YAAE;QAAM;QAE9E,IAAI,CAAC,MAAM,OAAO,CAAC,WAAW,OAAO,MAAM,KAAK,GAAG;YACjD,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAkC,GAC3C;gBAAE,QAAQ;YAAI;QAElB;QAEA,8CAA8C;QAC9C,MAAM,YAAY,6FAAA,CAAA,UAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,UAAU;QACrD,IAAI,CAAC,2FAAA,CAAA,UAAE,CAAC,UAAU,CAAC,YAAY;YAC7B,2FAAA,CAAA,UAAE,CAAC,SAAS,CAAC,WAAW;gBAAE,WAAW;YAAK;QAC5C;QAEA,8DAA8D;QAC9D,MAAM,aAAa,EAAE;QAErB,0BAA0B;QAC1B,KAAK,MAAM,CAAC,OAAO,KAAK,IAAI,OAAO,OAAO,GAAI;YAC5C,MAAM,WAAW,6FAAA,CAAA,UAAI,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,MAAM,KAAK,CAAC;YAC5D,MAAM,CAAA,GAAA,+GAAA,CAAA,YAAS,AAAD,EAAE,UAAU,OAAO,IAAI,CAAC,MAAM,YAAY,uCAAuC;YAC/F,WAAW,IAAI,CAAC,CAAC,kBAAkB,EAAE,MAAM,KAAK,CAAC,GAAG,8CAA8C;QACpG;QAEA,kCAAkC;QAClC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,WAAW;QACb;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,kCAAkC;QAEhD,+EAA+E;QAC/E,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAmD,GAC5D;YAAE,QAAQ;QAAI;IAElB;AACF"}},
    {"offset": {"line": 141, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}